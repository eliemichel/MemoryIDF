<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Memory pour le Grand Paris</title>

	<script src="https://api.mapbox.com/mapbox-gl-js/v2.9.1/mapbox-gl.js"></script>
	<link href="https://api.mapbox.com/mapbox-gl-js/v2.9.1/mapbox-gl.css" rel="stylesheet" />
	<script src="fuzzyset.js"></script>

	<style type="text/css">
		body {
			font-family: "Helvetica", sans-serif;
		}

		#map-container {
			width: 70%;
			position: absolute;
			left: 0;
			top: 0;
		}

		#map {
			width: 100%;
			height: 100vh;
			position: absolute;
			left: 0;
			top: 0;
		}

		#overlay {
			width: 100%;
			height: 100vh;
			position: absolute;
			left: 0;
			top: 0;
			pointer-events: none;
		}
		#overlay > div {
			pointer-events: auto;
		}

		#search-input-container {
			position: relative;
			width: 100%;
			max-width: 30em;
			margin: 1.5em auto;
		}

		#search-input {
			display: block;
			box-sizing: border-box;
			width: 100%;
			height: 2.5em;
			margin: 0;
			padding: 0.8em;
			pointer-events: auto;

			font-size: 1.2em;
			box-shadow: 0px 0px 10px rgba(0,0,0,0.2);
			border-radius: 1em;
  			border: 1px solid #ccc;
		}

		.notify-error #search-input {
			animation: 0.5s ease-out 0s 1 normal notify-error;
		}
		@keyframes notify-error {
			0% { transform: translateX(0); color: auto; }
			25% { transform: translateX(5px); color: #dd2200; }
			50% { transform: translateX(-5px); }
			75% { transform: translateX(5px); }
			100% { transform: translateX(0); color: auto; }
		}

		.notify-duplicate #search-input {
			animation: 0.5s ease-out 0s 1 normal notify-duplicate;
		}
		@keyframes notify-duplicate {
			0% { transform: translateX(0); color: auto; }
			25% { transform: translateX(5px); color: #0088ff; }
			50% { transform: translateX(-5px); }
			75% { transform: translateX(5px); }
			100% { transform: translateX(0); color: auto; }
		}

		.notify-success #search-input {
			animation: 1.0s linear 0s 1 normal notify-success;
		}
		@keyframes notify-success {
			0% { color: auto; }
			10% { color: #22a607; }
			100% { color: auto; }
		}

		#search-loader {
			position: absolute;
			width: 1.2em;
			height: 1.2em;
			right: 0.6em;
			top: 0.6em;
			border: 0.3em solid #00000020;
			border-radius: 100%;
			clip-path: polygon(0% 0%, 70% 0%, 50% 50%, 0% 70%);
			animation: 1s linear 0s infinite normal spin;
		}
		@keyframes spin {
			from { transform: rotate(0deg); }
			to { transform: rotate(360deg); }
		}

		#search-notification {
			position: absolute;
			height: 2.0em;
			line-height: 2.0em;
			right: 0.6em;
			top: 0.5em;
			padding: 0 0.8em;
			border-radius: 0.5em;
			opacity: 0;
		}

		.notify-error #search-notification {
			color: #dd2200;
			background-color: #ffd2ca;
			animation: 0.8s ease-out 0s 1 normal notification-popup;
		}
		@keyframes notification-popup {
			0% { transform: translateY(-5px); opacity: 0.0; }
			20% { transform: translateY(0); opacity: 1.0; }
			80% { transform: translateY(0); opacity: 1.0; }
		}

		.notify-duplicate #search-notification {
			color: #0088ff;
			background-color: #cae4fb;
			animation: 0.8s ease-out 0s 1 normal notification-popup;
		}

		.notify-success #search-notification {
			color: #22a607;
			background-color: #c5ffb9;
			animation: 0.8s ease-out 0s 1 normal notification-popup;
		}

		#scoreboard {
			box-sizing: border-box;
			position: absolute;
			right: 0;
			top: 0;
			width: 30%;
			height: 100vh;
			background-color: #b7c8d9;
			padding: 1em 1.5em;
			overflow-y: scroll;
		}

		#scoreboard > hr {
			border: none;
			height: 3px;
			border-radius: 2px;
			background-color: #a7bcd0;
			margin: 1em 0;
		}

		#stats > ul,
		#counts {
			margin: 0;
			padding: 0;
			list-style-type: none;
		}

		#counts li {
			text-transform: uppercase;
			color: #155a9f;
		}
		#counts li:nth-child(2) {
			font-size: 0.9em;
		}

		#menu button {
			border: 0;
			cursor: pointer;
			margin: 0;
			margin-top: 1em;
		}

		#found {
			margin: 0;
			padding: 0;
			list-style-type: none;
		}

		#found li {
			display: block;
			padding: 0.7em 0.7em;
			margin: 0.5em 0;
			border-radius: 0.3em;
			font-weight: bold;
			overflow: hidden;
		}
		#found li:hover {
			background: #a7bcd0;
			cursor: pointer;
		}
		#found li.new {
			animation: 0.2s ease-out 0s 1 normal reveal;
		}
		@keyframes reveal {
			from { max-height: 0em; padding: 0 1em; }
			to { max-height: 2.5em; padding: 0.7em 1em; }
		}

		#found li .logo {
			display: inline-block;
			width: 1.1em;
			margin-right: 0.5em;
			vertical-align: sub;
		}

		.percentage {
			font-weight: bold;
			font-size: 1.25em;
		}
		.percentage::after {
			font-weight: normal;
			margin-left: 0.1em;
			content: '%';
		}

		@media (max-width: 1000px) {
			#map-container {
				width: 100%;
			}

			#search-input-container {
				margin-top: 13.5em;
			}

			#scoreboard {
				left: calc((100vw - 30em) / 2);
				width: 100%;
				max-width: 30em;
				height: 14em;
				padding-top: 0.4em;
				overflow: hidden;
				font-size: 0.9em;
			}

			#scoreboard > hr {
				height: 2px;
				margin: 0.5em 0;
			}

			#found {
				display: none;
			}
		}

	</style>
</head>
<body>
	<main>
		<div id="map-container">
			<div id="map"></div>
			<div id="overlay">
				<form id="search-form" action="javascript:void(0);">
					<div id="search-input-container">
						<input id="search-input" type="text" name="guess" placeholder="Entrez le nom d'une commune ou gare" disabled />
						<div id="search-loader"></div>
						<div id="search-notification">Test</div>
					</div>
				</form>
			</div>
		</div>

		<div id="scoreboard">
			<div id="stats">
				<ul>
					<li><span class="percentage" id="stat-communes">X</span> de communes trouvées</li>
					<li><span class="percentage" id="stat-surface">X</span> d'hectares trouvés</li>
					<li><span class="percentage" id="stat-inhabitants">X</span> d'habitants trouvés</li>
					<li><span class="percentage" id="stat-stations">X</span> de gares trouvées</li>
					<li><span class="percentage" id="stat-forest">0.0</span> de parcs et forêts trouvés</li>
				</ul>
			</div>
			<div id="menu">
				<button id="btn-export">Export</button>
				<button id="btn-import">Import</button>
			</div>
			<hr />
			<div>
				<ul id="counts">
					<li><span id="count-stations">X</span> gares</li>
					<li><span id="count-communes">X</span> communes (<span id="count-surface">X</span> ha, <span id="count-inhabitants">X</span> k habitants)</li>
				</ul>

				<ul id="found">
				</ul>
			</div>
		</div>
	</main>

	<script>
// NB: Variable starting with $ are promises.

///////////////////////////////////////////////////////////
// Immutable configuration globals

const config = {
	// for quick debug iterations, hide maps (do not even load it)
	DISABLE_MAP: false,

	// MapBox access token (only allowed on specific hosts so you can use it
	// localhost but not steal it for your website)
	MAPBOX_ACCESS_TOKEN: 'pk.eyJ1IjoiZWxpZW1pY2hlbCIsImEiOiJjbG56d2wydHgxN3ppMmtxb3ByMjhkdW82In0.iDZGP4LZtOPIYgr1XdqY5w'
};

///////////////////////////////////////////////////////////
// Global state

// This is the only place where user data is stored
const state = {
	// Elements that have been found by the user
	found: [],

	// Temporary state that does not need to be serialized
	loading: true,
	notifyingError: false,
	notifyingDuplicate: false,
	notifyingSuccess: false,

	// Values that can be recomputed at any time from the rest of the state
	cache: {
		counts: { // raw values
			communes: 0,
			surface: 0, // in hectare
			inhabitants: 0, // in thousands of people
			stations: 0,
		},
		stats: { // percentages
			communes: 0.0,
			surface: 0.0,
			inhabitants: 0.0,
			stations: 0.0,
		},
		totalCounts: { // from data loader
			communes: -1,
			surface: -1, // in hectare
			inhabitants: -1, // in thousands of people
			stations: -1,
		},
		foundKeys: {}, // speed up duplicate detection

		// We accumulate here the stations we find
		foundStationsGeojson: {
			type: "FeatureCollection",
			features: [],
		},
	}
};

///////////////////////////////////////////////////////////
// DOM binding

const $DOMContentLoaded = new Promise((resolve) => {
	document.addEventListener('DOMContentLoaded', resolve);
});

// Whenever DOM is ready, we get all the elements we eventually need to update.
const $dom = $DOMContentLoaded.then(() => {
	return [
		"search-input",
		"search-form",
		"search-loader",
		"search-notification",
		"scoreboard",
		"btn-export",
		"btn-import",
		"found",
		"stat-communes",
		"stat-surface",
		"stat-inhabitants",
		"stat-stations",
		"count-communes",
		"count-surface",
		"count-inhabitants",
		"count-stations",
	].reduce((acc, item) => {
		acc[item] = document.getElementById(item);
		return acc;
	}, {});
});

///////////////////////////////////////////////////////////
// Actions

// Unlike a typical Reduc pattern, actions are not pure.
// We implement this pattern in case we eventually need it, but as long as
// there is nothing like undo/redo system we do not need multiple copies of the
// state so everything can happen in place.
const Action = {
	InitializeStationCache: (stations) => (dom, state) => {
		state.cache.totalCounts.stations = stations.features.length;
		state.cache.stats.stations = 100 * state.cache.counts.stations / state.cache.totalCounts.stations;
		renderScoreboard(dom, state, 0);
	},

	StartLoading: () => (dom, state) => {
		state.loading = true;
		renderSearchForm(dom, state);
	},

	StopLoading: () => (dom, state) => {
		state.loading = false;
		renderSearchForm(dom, state);
	},

	// Invoked when the player query does not match any entry
	NotifyError: () => (dom, state) => {
		if (!state.notifyingError) {
			state.notifyingError = true;
			renderSearchForm(dom, state);
			setTimeout(() => {
				state.notifyingError = false;
				renderSearchForm(dom, state);
			}, 1000);
		}
	},

	// Invoked when the player query does not match any entry
	NotifyDuplicate: () => (dom, state) => {
		if (!state.notifyingDuplicate) {
			state.notifyingDuplicate = true;
			renderSearchForm(dom, state);
			setTimeout(() => {
				state.notifyingDuplicate = false;
				renderSearchForm(dom, state);
			}, 1000);
		}
	},

	// Invoked when the player query does not match any entry
	NotifySuccess: () => (dom, state) => {
		if (!state.notifyingSuccess) {
			state.notifyingSuccess = true;
			renderSearchForm(dom, state);
			setTimeout(() => {
				state.notifyingSuccess = false;
				renderSearchForm(dom, state);
			}, 1000);
		}
	},

	AppendFoundStationItem: (item, geoFeature) => (dom, state) => {
		if (state.cache.foundKeys[item.id]) return;
		state.cache.foundKeys[item.id] = true;

		state.found = [
			item,
			...state.found
		];
		++state.cache.counts.stations;
		state.cache.stats.stations = 100 * state.cache.counts.stations / state.cache.totalCounts.stations;
		renderScoreboard(dom, state, 0);

		// Update map
		state.cache.foundStationsGeojson.features.push({
			...geoFeature,
			id: item.id[1]
		});
		$map.then(map => {
			map.getSource('found-stations').setData(state.cache.foundStationsGeojson);
		});

		localStorage.setItem("savedState", JSON.stringify(state));
	},

	// This loads a brand new state and recomputes the cached values
	// NB: This also has the effect of StopLoading after loading state
	LoadState: (newState, stations) => (dom, state) => {
		state.found = newState.found;
		state.cache = {
			counts: { // raw values
				communes: 0,
				surface: 0, // in hectare
				inhabitants: 0, // in thousands of people
				stations: 0,
			},
			stats: { // percentages
				communes: 0.0,
				surface: 0.0,
				inhabitants: 0.0,
				stations: 0.0,
			},
			totalCounts: { // from data loader
				communes: -1,
				surface: -1, // in hectare
				inhabitants: -1, // in thousands of people
				stations: stations.features.length,
			},
			foundKeys: {}, // speed up duplicate detection

			// We accumulate here the stations we find
			foundStationsGeojson: {
				type: "FeatureCollection",
				features: [],
			},
		};
		// Build a temporary mapping from id to geoFeatures (TODO: use stationData.idToIndex)
		const stationIdToIndex = {};
		stations.features.map((entry, index) => {
			stationIdToIndex[entry.properties.id_gares] = index;
		});

		state.found.map(item => {
			if (item.id[0] === 'STATION') {
				state.cache.foundKeys[item.id] = true;
				const stationIndex = stationIdToIndex[item.id[1]];
				state.cache.foundStationsGeojson.features.push({
					...stations.features[stationIndex],
					id: item.id[1]
				});
				++state.cache.counts.stations;
				state.cache.stats.stations = 100 * state.cache.counts.stations / state.cache.totalCounts.stations;
			}
		});

		$map.then(map => {
			const src = map.getSource('found-stations');
			if (src) { // may not be loaded yet
				src.setData(state.cache.foundStationsGeojson);
			}
		});

		renderScoreboard(dom, state);

		state.loading = false;
		renderSearchForm(dom, state);

		localStorage.setItem("savedState", JSON.stringify(state));
	},
};
function dispatch(dom, action) {
	action(dom, state);
}

///////////////////////////////////////////////////////////
// Render functions (responsible for updating the DOM)

function renderScoreboard(dom, state, newIndex) {
	dom["stat-communes"].innerText = state.cache.stats.communes.toFixed(1);
	dom["stat-surface"].innerText = state.cache.stats.surface.toFixed(1);
	dom["stat-inhabitants"].innerText = state.cache.stats.inhabitants.toFixed(1);
	dom["stat-stations"].innerText = state.cache.stats.stations.toFixed(1);

	dom["count-communes"].innerText = state.cache.counts.communes;
	dom["count-surface"].innerText = state.cache.counts.surface.toFixed(1);
	dom["count-inhabitants"].innerText = state.cache.counts.inhabitants.toFixed(1);
	dom["count-stations"].innerText = state.cache.counts.stations;

	dataLoader.$stationData.then(stationData => {
		dom.found.replaceChildren(...state.found.map((item, index) => {
			const isNew = index == newIndex;
			return renderScorboardFoundEntry(item, stationData, isNew);
		}));
	});
}

function renderScorboardFoundEntry(item, stationData, isNew) {
	const className = isNew ? "new" : "";

	var logo = "";
	var center = [0, 0];
	if (item.id[0] == 'STATION' && stationData != null) {
		const index = stationData.idToIndex[item.id[1]];
		const feature = stationData.stations.features[index];
		const props = feature.properties;
		logo = `<img src="${props.logo}" class="logo" />`;
		center = feature.geometry.coordinates.slice();
	}

	const element = document.createElement('li');
	element.setAttribute("class", isNew ? "new" : "");
	element.setAttribute("title", "Trouvé le XXX à XXXh");
	element.innerHTML = `${logo}${item.name}`;

	$map.then(map => {
		element.addEventListener('mouseenter', () => {
			map.setFeatureState(
				{ source: 'found-stations', id: item.id[1] },
				{ active: true }
			);
		});
		element.addEventListener('mouseleave', () => {
			map.setFeatureState(
				{ source: 'found-stations', id: item.id[1] },
				{ active: false }
			);
		});
		element.addEventListener('click', () => {
			map.flyTo({
				center,
				zoom: 13,
			});
		});
	});

	return element;
}

function renderSearchForm(dom, state) {
	const input = dom["search-input"];
	const form = dom["search-form"];
	const notif = dom["search-notification"];
	const loader = dom["search-loader"];
	const wasDisabled = input.disabled;
	input.disabled = state.loading;
	if (wasDisabled && !input.disabled) {
		//input.selectionStart = 0;
		//input.selectionEnd = input.value.length;
		input.focus();
	}
	form.setAttribute("class",
		state.notifyingError ? "notify-error" :
		state.notifyingDuplicate ? "notify-duplicate" :
		state.notifyingSuccess ? "notify-success" : ""
	);
	notif.innerText =
		state.notifyingError ? "Non !" :
		state.notifyingDuplicate ? "Déjà trouvé !" :
		state.notifyingSuccess ? "Bravo !" : "";
	loader.style.visibility = state.loading ? "visible" : "hidden";
}

///////////////////////////////////////////////////////////
// Utils

// Utility function to create and download a file
function exportFile(filename, text) {
	var element = document.createElement('a');
	element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
	element.setAttribute('download', filename);

	element.style.display = 'none';
	document.body.appendChild(element);

	element.click();

	document.body.removeChild(element);
}

// Open a file browser to load a json file
function importJsonFile() {
	return new Promise((resolve, reject) => {
		const element = document.createElement('input');
		element.setAttribute('type', 'file');
		element.setAttribute('accept', '*.json');
		element.addEventListener("change", event => {
			const reader = new FileReader();
			reader.addEventListener('load', () => {
				resolve(JSON.parse(reader.result));
			});
			reader.readAsText(element.files[0]);
		}, false);

		element.style.display = 'none';
		document.body.appendChild(element);
		element.click();
		document.body.removeChild(element);
	});
}

///////////////////////////////////////////////////////////
// Data loader

// Start fetching data right away
const dataLoader = {
	$traces:
		fetch('data/memory-pour-idf-trainline-traces.geojson')
		.then(response => response.json()),

	$stations:
		fetch('data/memory-pour-idf-stations.geojson')
		.then(response => response.json()),

	$stationsMeta:
		fetch('data/memory-pour-idf-stations-metadata.geojson')
		.then(response => response.json()),

	// Post-operations are populated below because the rely on other members of
	// the dataLoader.

	// Names to be guessed
	$memory: null,

	// Stores both stations and metadata + a precomputed id -> index mapping
	$stationData: null,
};


dataLoader.$stationData = Promise.all([dataLoader.$stations, dataLoader.$stationsMeta])
.then(([stations, meta]) => {
	const idToIndex = {};
	stations.features.map((entry, index) => {
		idToIndex[entry.properties.id_gares] = index;
	});
	return {
		idToIndex,
		stations,
		meta,
	}
});


// Structure hiding the mechanism through which we fix small typos in user guesses
class MemoryEngine {
	constructor() {
		this.data = {}; // naive baseline
	}

	insert(key, value) {
		const nkey = this._normalizeKey(key);
		this.data[nkey] = value;
	}

	// This is called after all insert and before all search
	freeze() {
		this.fuzzyset = FuzzySet(Object.keys(this.data));
	}

	search(query) {
		return new Promise((resolve, reject) => {
			const nkey = this._normalizeKey(query);
			console.log(nkey);

			// naive baseline
			//resolve(this.data[nkey]);

			// fuzzyset
			const results = this.fuzzyset.get(nkey, null, 0.9);
			if (results == null) resolve(null);
			else resolve(this.data[results[0][1]]);
		});
	}

	_normalizeKey(str) {
		return str
			.normalize("NFD")
			.replace(/[\u0300-\u036f]/g, "")
			.replace(/-/g, ' ')
			.replace(/\s+/g, ' ')
			.toLowerCase();
	}
}

// Add post-loading operations
dataLoader.$memory = dataLoader.$stations.then(stations => {
	const engine = new MemoryEngine();
	stations.features.map((item, index) => {
		const props = item.properties;
		const payload = {
			type: 'STATION',
			index
		};
		// nom de gare seul:
		engine.insert(props.nom_gares, payload);
		engine.insert(props.nom_iv, payload);
		// nom + sous titre (possible de deviner mais bon courage):
		engine.insert(props.nom_zdc, payload);
	});
	engine.freeze();
	return engine;
});

///////////////////////////////////////////////////////////
// Setup DOM event listeners

$dom.then(dom => {
	renderScoreboard(dom, state);
	renderSearchForm(dom, state);
});

Promise.all([$dom, dataLoader.$stations])
.then(([dom, stations]) => {
	const savedStateJson = localStorage.getItem("savedState");
	if (savedStateJson !== null) {
		let savedState;
		try {
			savedState = JSON.parse(savedStateJson);
		} catch (e) {
			console.log("Invalid saved state:");
			console.log(e);
			return;
		}
		dispatch(dom, Action.LoadState(savedState, stations));
	}

	dom["btn-export"].addEventListener('click', () => {
		exportFile("memory-pour-idf.json", JSON.stringify({
			...state,
			cache: null,
		}, null, 2));
	});
	dom["btn-import"].addEventListener('click', () => {
		dispatch(dom, Action.StartLoading());
		importJsonFile()
		.then((json) => {
			dispatch(dom, Action.LoadState(json, stations));
		});
	});
});

const $gameplayReady = Promise.all([$dom, dataLoader.$memory, dataLoader.$stationData])
.then(([dom, memory, stationData]) => {
	const stations = stationData.stations;
	// We can now add the search event handler
	dom["search-form"].addEventListener('submit', () => {
		if (state.loading) return;
		const query = dom["search-input"].value;

		dispatch(dom, Action.StartLoading());

		memory.search(query).then(result => {
			if (result == null) {
				dispatch(dom, Action.NotifyError());
			} else {
				if (result.type == 'STATION') {

					const props = stations.features[result.index].properties;
					const item_id = ['STATION', props.id_gares];

					const alreadyFound = state.cache.foundKeys[item_id];
					if (alreadyFound) {
						dispatch(dom, Action.NotifyDuplicate());
					} else {
						const connected_ids = stationData.meta['connected-stations'][props.id_gares] || [props.id_gares];

						connected_ids.map(id => {

							const index = stationData.idToIndex[id];
							const props = stations.features[index].properties;
							dispatch(dom, Action.AppendFoundStationItem({
								id: ['STATION', props.id_gares],
								name: props.nom_zdc,
							}, stations.features[index]));

						});

						dispatch(dom, Action.NotifySuccess());
					}
				}
			}

			dispatch(dom, Action.StopLoading());
		});
	});

	dispatch(dom, Action.InitializeStationCache(stations));
	dispatch(dom, Action.StopLoading());
});

///////////////////////////////////////////////////////////
// Map

const $map = new Promise((resolve, reject) => {
	if (config.DISABLE_MAP) {
		// Just never resolve
		console.log("Map is disabled");
	} else {
		mapboxgl.accessToken = config.MAPBOX_ACCESS_TOKEN;

		const map = new mapboxgl.Map({
			container: 'map',
			style: 'mapbox://styles/eliemichel/clnzwjzoj007i01qxg4vcf4m0',
			center: [2.3522, 48.8566],
			maxBounds: [
				[0.75, 47.8566],
				[4.0, 49.8566]
			],
			zoom: 9.5,
		});

		map.on('load', () => { resolve(map); });
	}
});

Promise.all([$map, dataLoader.$traces])
.then(([map, traces]) => {

	map.addSource('traces', {
		type: 'geojson',
		data: traces
	});

	// Add a symbol layer showing all train lines
	map.addLayer({
		id: 'line-train',
		type: 'line',
		source: 'traces',
		paint: {
			"line-color": ["get", "color"],
			"line-width": 3,
			//"line-offset": ["*", 3, ["interpolate",
			//	['linear'],
			//	0.0, ["get", "start-line-offset"],
			//	1.0, ["get", "end-line-offset"],
			//]],
			"line-offset": ["*", 3, ["get", "line-offset"]],
		}
	});

	// When a click event occurs on a train line, open a popup at the
	// location of the feature, with description HTML from its properties.
	map.on('click', 'line-train', (e) => {
		// Copy coordinates array.
		const coordinates = e.features[0].geometry.coordinates.slice();
		const props = e.features[0].properties;

		// Ensure that if the map is zoomed out such that multiple
		// copies of the feature are visible, the popup appears
		// over the copy being pointed to.
		while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
			coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
		}

		console.log(e.features[0]);

		const description = `
		<img src="${props.logo}" alt="logo" style="max-width: 30%;" />
		<ul>
		<li>exploitant: ${props.exploitant}</li>
		<li>idf: ${props.idf != 0}</li>
		<li>indice_lig: ${props.indice_lig}</li>
		<li>metro: ${props.metro != 0}</li>
		<li>mode: ${props.mode}</li>
		<li>rer: ${props.rer != 0}</li>
		<li>res_com: ${props.res_com}</li>
		<li>reseau: ${props.reseau}</li>
		<li>train: ${props.train != 0}</li>
		<li>tramway: ${props.tramway != 0}</li>
		<li>(orly?)val: ${props.val != 0}</li>
		</ul>
		`;

		new mapboxgl.Popup()
			.setLngLat(e.lngLat)
			.setHTML(description)
			.addTo(map);
	});

	// Change the cursor to a pointer when the mouse is over the train line layer.
	map.on('mouseenter', 'line-train', () => {
		map.getCanvas().style.cursor = 'pointer';
	});

	// Change it back to a pointer when it leaves.
	map.on('mouseleave', 'line-train', () => {
		map.getCanvas().style.cursor = '';
	});
});

Promise.all([$map, dataLoader.$stations])
.then(([map, stations]) => {

	// Add a GeoJSON source containing place coordinates and information.
	map.addSource('stations', {
		type: 'geojson',
		data: stations
	});

	// Add a symbol layer showing all train stations before they are found
	map.addLayer({
		id: 'pending-stations',
		type: 'circle',
		source: 'stations',
		minzoom: 11,
		paint: {
			//'circle-color': ['get', 'color'],
			'circle-radius': 3,
			'circle-stroke-color': '#000000',
			'circle-stroke-opacity': 0.5,
			'circle-stroke-width': 1,
			'circle-color': '#ffffff',
			'circle-opacity': 1.0,
		}
	});

	map.addSource('found-stations', {
		'type': 'geojson',
		'data': state.cache.foundStationsGeojson,
	});

	// Add a symbol layer showing all train stations that have been found
	map.addLayer({
		id: 'found-stations',
		type: 'circle',
		source: 'found-stations',
		paint: {
			'circle-radius': ["case",
				["boolean", ["feature-state", "active"], false],
				6,
				4,
			],
			'circle-stroke-color': '#000000',
			'circle-stroke-opacity': 0.7,
			'circle-color': ['get', 'color'],
			'circle-stroke-width': 1,
			'circle-stroke-color': "#000000",
		}
	});
	map.addLayer({
		id: 'found-stations-labels',
		type: 'symbol',
		source: 'found-stations',
		layout: {
			'text-anchor': 'bottom',
			'text-offset': [0, -0.5],
			'text-field': ['get', 'nom_zdc'],
			'text-size': 13,
			'text-font': ["Open Sans Regular", "Arial Unicode MS Regular"],
		},
		paint: {
			'text-halo-blur': ["case",
				["boolean", ["feature-state", "active"], false],
				1,
				2,
			],
			'text-halo-color': ["case",
				["boolean", ["feature-state", "active"], false],
				"rgba(255, 200, 80, 1.0)",
				"rgba(255, 255, 255, 1.0)",
			],
			'text-halo-width': 1,
		}
	});

	// When a click event occurs on a train station, open a popup at the
	// location of the feature, with description HTML from its properties.
	map.on('click', 'found-stations', (e) => {
		// Copy coordinates array.
		const coordinates = e.features[0].geometry.coordinates.slice();
		const props = e.features[0].properties;
		console.log(props);
		console.log("id");
		console.log(e.features[0].id);

		// Ensure that if the map is zoomed out such that multiple
		// copies of the feature are visible, the popup appears
		// over the copy being pointed to.
		while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
			coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
		}

		const description = `
		<img src="${props.picto}" alt="logo" style="max-width: 30%;" />
		<ul>
		<li>exploitant: ${props.exploitant}</li>
		<li>idf: ${props.idf != 0}</li>
		<li>indice_lig: ${props.indice_lig}</li>
		<li>mode: ${props.mode}</li>
		<li>nom_gares: ${props.nom_gares}</li>
		<li>nom_iv: ${props.nom_iv}</li>
		<li>nom_so_gar: ${props.nom_so_gar}</li>
		<li>nom_zda: ${props.nom_zda}</li>
		<li>nom_zdc: ${props.nom_zdc}</li>
		<li>principal: ${props.principal != 0}</li>
		<li>res_com: ${props.res_com}</li>
		<li>metro: ${props.termetro != "0"}</li>
		<li>rer: ${props.terrer != "0"}</li>
		<li>train: ${props.tertrain != "0"}</li>
		<li>tramway: ${props.tertram != "0"}</li>
		<li>val: ${props.terval != "0"}</li>
		</ul>
		`;

		new mapboxgl.Popup()
			.setLngLat(coordinates)
			.setHTML(description)
			.addTo(map);
	});

	// Change the cursor to a pointer when the mouse is over the train line layer.
	map.on('mouseenter', 'found-stations', () => {
		map.getCanvas().style.cursor = 'pointer';
	});

	// Change it back to a pointer when it leaves.
	map.on('mouseleave', 'found-stations', () => {
		map.getCanvas().style.cursor = '';
	});
});
	</script>
}

</body>
</html>
